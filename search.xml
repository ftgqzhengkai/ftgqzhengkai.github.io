<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于线程池]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[什么是线程池 为什么要使用线程池 ThreadPoolExecutor说明 什么是线程池 线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。 为什么要用线程池 创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率 线程并发数量过多，抢占系统资源从而导致阻塞 对线程进行一些简单的管理 （延时执行、定时循环执行的策略等） 线程池ThreadPoolExecutor构造函数12345678910111213141516171819202122232425262728293031//五个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)//六个参数的构造函数-1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//六个参数的构造函数-2public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//七个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor构造函数参数说明1. corePoolSize -&gt; 该线程池中核心线程数最大值 核心线程：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会一直存在于线程池中（即使这个线程啥都不干），有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。 2. maximumPoolSize -&gt; 该线程池中线程总数最大值 线程总数=核心线程数+非核心线程数非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程 3. keepAliveTime -&gt; 非核心线程闲置超时时长 这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。 4. TimeUnit -&gt; keepAliveTime的单位 TimeUnit是一个枚举类型，其包括:NANOSECONDS ： 1微毫秒 = 1微秒 / 1000MICROSECONDS ： 1微秒 = 1毫秒 / 1000MILLISECONDS ： 1毫秒 = 1秒 /1000SECONDS ： 秒MINUTES ： 分HOURS ： 小时DAYS ： 天 5. BlockingQueue workQueue -&gt; 线程池中的任务队列 默认情况下，任务进来之后先分配给核心线程执行，核心线程如果都被占用，并不会立刻开启非核心线程执行任务，而是将任务插入任务队列等待执行，核心线程会从任务队列取任务来执行，任务队列可以设置最大值，一旦插入的任务足够多，达到最大值，才会创建非核心线程执行任务。常见的workQueue有四种： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前已经创建的核心线程数小于线程池的核心线程数上限，则新建线程(核心线程)处理任务；如果当前已经创建的核心线程数等于核心线程数上限，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误，或是执行实现定义好的饱和策略 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务 6. ThreadFactory threadFactory -&gt; 创建线程的工厂 可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 7. RejectedExecutionHandler handler -&gt; 饱和策略 这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy， 表示无法处理新任务，并抛出 RejectedExecutionException 异常。此外还有3种策略，它们分别如下： CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。 别晕，接下来上图，相信结合图你能大彻大悟~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo同步博客]]></title>
    <url>%2F2017%2F03%2F27%2Fhexo%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo搭建过程网上很多，这里就不叙述。主要说说在不同电脑之间同步hexo博客。 远程仓库的创建可以使用github、OSC、coding等等，最好选择私有库，由于github只能私有库不是免费的，想节省点的可以选择免费的私有库（比如OSC、coding）。 将git SSH公钥添加至远程仓库。 .gitignore操作在hexo根目录下新建或打开.gitignore1234/.deploy_git/public /_config.yml/node_modules /.deploy_git 以及 /public 文件在进行hexo d时会重新生成/node_modules 使用npm install或cnpm install(淘宝镜像)会重新生成/_config.yml自行保存，如不在意可以上传到远程仓库中 上传hexo文件到远程仓库在hexo根目录下打开Git Bash1234567git config --global user.name "Your Name"git config --global user.email "email@example.com"git initgit add .git commit -m "first commit"git remote add origin ssh地址git push -u origin master 其他电脑端操作安装hexo过程不在叙述，进行到hexo init这步无需再执行 在Git Bash界面下把项目同步下来1git clone ssh地址 如_config.yml文件自行保存复制进项目根目录继续如下操作1npm install 或 cnpm install(淘宝镜像) 运行hexo,以后要在本地运行博客只要输入该命令即可1hexo s -g 打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 安装hexo git插件12npm install hexo-deployer-git --save 或 cnpm install hexo-deployer-git --save（淘宝镜像） 发布更新博客1hexo d -g 发布成功后，访问博客page地址查看看下成果即可！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>
